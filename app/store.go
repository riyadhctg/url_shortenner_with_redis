package main

import (
	"sync"
)

// struct is collection of fields whereas interface type is a set of method signature
// Go doesn't have class but you can define methods on types
/**
method vs function: methods are functions with a special receiver argument. For example:
func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
ref: https://go.dev/tour
*/

type URLStore struct {
	mu   sync.RWMutex
	save chan record
	rd   *RedisClient
}

type record struct {
	key, URL string
}

const saveQueueLength = 1000

func NewURLStore(filename string) *URLStore {
	// maps are reference type
	// new just allocates memory, not initializes memory; make allocates and initializes memory
	s := &URLStore{
		save: make(chan record, saveQueueLength),
		rd:   NewRedisClient(),
	}

	go s.saveloop(s.rd)
	return s
}

/**
Methods with pointer receivers can modify the value to which the receiver points (as Scale does here).
Since methods often need to modify their receiver, pointer receivers are more common than value receivers.
ref: https://go.dev/tour
*/
func (s *URLStore) Get(key string) string {
	s.mu.RLock()
	defer s.mu.RUnlock()
	val, err := s.rd.RedisGet(key)
	if err != nil {
		panic(err)
	}
	return val
}

func (s *URLStore) Set(key, url string) bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	if _, err := s.rd.RedisGet(key); err == nil {
		return false
	}
	return true
}

func (s *URLStore) saveloop(rd *RedisClient) {
	for {
		// taking a record from the channel
		r := <-s.save
		// then saving it on Redis
		rd.RedisSet(r.key, r.URL)
	}

}

func (s *URLStore) Put(url string) string {
	// for {} is infinite loop so there must be something inside the loop to break out of the loop
	// this for loop keeps trying until a unique key is generated by genbKey
	// for existing keys, our Set method will return false, so the loop will continue
	for {
		key := genKey()
		if ok := s.Set(key, url); ok {
			s.save <- record{key, url}
			return key
		}

	}
	panic("shouldn't get here")
}
